#!/usr/bin/env lua

local VERSION = '0.1.0'
local DEBUG   = false

local function script_path()
	local str = debug.getinfo(2, "S").source:sub(2)
	return str:match("(.*/)")
end
package.path = package.path .. ';'  .. script_path() ..'lib/?.lua'

local util = require("myutil")
package.path = package.path .. ';'  .. os.getenv("HOME") .. '/.luarocks/share/lua/'.. util.split(_VERSION, "%s")[2] ..'/?.lua'

local alt_getopt     = require("alt_getopt")
local posix_pwd      = require("posix.pwd")
local posix_unistd   = require("posix.unistd")
local posix_sys_stat = require("posix.sys.stat")
local dkjson         = require("dkjson")
local http_util      = require("http.util")

local pl_pretty  = require("pl.pretty")
local pl_types   = require("pl.types")
local pl_stringx = require("pl.stringx")
local pl_tablex  = require("pl.tablex")

local cqueues   = require("cqueues")
local socket    = require("cqueues.socket")
local errno     = require("cqueues.errno")
local condition = require("cqueues.condition")
local signal    = require("cqueues.signal")

--local EAGAIN = errno.EAGAIN
local EPIPE  = errno.EPIPE
local poll   = cqueues.poll

local log               = require('mylogger')
local httprequestparser = require('httprequestparser')
local config            = require('myconfig')


local long_opts = {
	help        = "h",
	version     = "v",
	debug       = "d",
	user        = "u",
	to_user     = 1,    -- 1 parameter must have an argument, 0 - should not
	docker_sock = 1,
	show_acl    = 0,
	no_acl      = 0,
	no_add_all_labels = 0,
}

local help_txt = [[
USAGE:
    this_daemon [OPTION] --to_user user_name
OPTIONS:
    -h    print help and exit
    -v    print version and exit
    -d    debug mode
    -u    user_name (default 'prdocker')
    --docker_sock    path to docker.sock (default '/run/docker.sock')
    --to_user        user_name
        A socket is created using a template /run/docker_[%user_name%].sock
        After starting this daemon, you need to add 'export DOCKER_HOST=unix:///run/docker_[%user_name%].sock' in ~/.bashrc
    --show_acl             show acl for --to_user and exit
    --no_acl               disable acl
    --no_add_all_labels    tell this_daemon not to add any of his own labels.
        By default, labels are added when creating a container, image, volume, or network.
]]
local optarg, _ = alt_getopt.get_opts(arg, "hvdu:", long_opts)

if optarg['d'] then
	DEBUG = true
end

if optarg['h'] then
	print(help_txt)
	os.exit(0)
end

if optarg['v'] then
	print(VERSION)
	os.exit(0)
end

if not optarg['to_user'] then
	log.err("can't find the required option: to_user")
	os.exit(1)
end
local pwd_to_user = posix_pwd.getpwnam(optarg['to_user'])
if not pwd_to_user then
	log.err("user '%s' not found", optarg['to_user'])
	os.exit(1)
end

if not optarg['u'] then
	optarg['u'] = 'prdocker'
end
local pwd_user = posix_pwd.getpwnam(optarg['u'])
if not pwd_user then
	log.err("user '%s' not found", optarg['u'])
	os.exit(1)
end

if not optarg['docker_sock'] then
	optarg['docker_sock'] = '/run/docker.sock'
end
local stat_docker_sock, err = posix_sys_stat.stat(optarg['docker_sock'])
if not stat_docker_sock then
	log.err("cannot stat %s", err)
	os.exit(1)
end

-- acl
local acl, err = config.parse_acl(optarg['to_user'])
if not acl then
	log.err("cannot parse acl file: %s", err)
	os.exit(1)
end
if optarg['show_acl'] then
	pl_pretty(acl)
	--print(util.dumpvar(acl))
	os.exit()
end


log.info("start proxydockersock daemon; version=%s", VERSION)


local to_user_sock = '/run/docker_'..optarg["to_user"]..'.sock'
local srv          = socket.listen({path = to_user_sock, mask = '0117', unlink = true})
log.info("listen: %s; proxying to %s", to_user_sock, optarg['docker_sock'])


local ok, err = posix_unistd.chown(to_user_sock, pwd_user["pw_uid"], pwd_to_user["pw_gid"])
if not ok then
	log.err("cannot chown %s", err)
	os.exit(1)
end


-- let's lower the privileges
-- we change both (real and effective) identifiers, because that's what the POSIX module in perl does.
local ok, err = posix_unistd.setpid('g', stat_docker_sock["st_gid"])
if not ok then
	log.err("cannot setgid %s", err)
	os.exit(1)
end
local ok, err = posix_unistd.setpid('G', stat_docker_sock["st_gid"])
if not ok then
	log.err("cannot setegid %s", err)
	os.exit(1)
end
local ok, err = posix_unistd.setpid('u', pwd_user["pw_uid"])
if not ok then
	log.err("cannot setuid %s", err)
	os.exit(1)
end
local ok, err = posix_unistd.setpid('U', pwd_user["pw_uid"])
if not ok then
	log.err("cannot seteuid %s", err)
	os.exit(1)
end

log.info("setting lower privileges; uid: %s; gid: %s", pwd_user["pw_uid"], stat_docker_sock["st_gid"])


-- cd $HOME
local ok, err = posix_unistd.chdir(pwd_user["pw_dir"])
if not ok then
	log.err("cannot chdir %s", err)
	os.exit(1)
end


local function send_deny_to_client(con, blocked_reason)
	local reason   = blocked_reason or "unknown"
	local response = '{"message":"denied by proxydockersock: ' .. reason .. '"}\n'
	
	con:write("HTTP/1.1 403 Forbidden\r\n")
	con:write("Content-Type: application/json\r\n")
	con:write("Content-Length: "..#response.."\r\n")
	con:write("Server: proxydockersock\r\n")
	con:write("\r\n")
	con:write(response)
end

local loop = cqueues.new()
local cons = {} -- connections
local docker_label_owner = {['krpsh123.proxydockersock.owner'] = optarg["to_user"]}

local function get_empty_req_client()
	return {
		buff     = '',
		headers  = {},
		is_ready = false,
		method   = '',
		uri      = '',
		uri_long = '',
		params   = {},
		http_version = '',
	}
end

local function change_request(id, new_body)
	-- https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages
	
	local new_buff = {}
	
	-- request line
	local req_line = cons[id].req_client.method
	if pl_types.is_empty(cons[id].req_client.params) then
		req_line = req_line .. " " .. cons[id].req_client.uri_long
	else
		local params_str = http_util.dict_to_query(cons[id].req_client.params)
		-- dict_to_query does it itself encoded
		req_line = req_line .. " " .. cons[id].req_client.uri.."?"..params_str
	end
	req_line = req_line .. " " .. cons[id].req_client.http_version.."\r\n"
	table.insert(new_buff, req_line)
	
	
	-- headers
	for k,v in pairs(cons[id].req_client.headers) do
		if k == 'content-length' then
			v = string.len(new_body)
		end
		table.insert(new_buff,k..": "..v.."\r\n")
	end
	
	
	-- empty line
	table.insert(new_buff, "\r\n")
	
	
	-- body
	if not pl_types.is_empty(new_body) then
		table.insert(new_buff, new_body)
	end
	
	--print("=====================")
	--print(cons[id].req_client.buff)
	--print("=====================")
	--print(table.concat(new_buff))
	--print("=====================")
	
	cons[id].req_client.buff = table.concat(new_buff)
	return true
end

local function add_owner_label(id)
	-- is tcp connect
	if cons[id].is_tcp then
		return true
	end
	
	-- disabled added all labels
	if optarg["no_add_all_labels"] then
		return true
	end
	--print(cons[id].req_client.method .. " " .. cons[id].req_client.uri)
	
	if cons[id].req_client.method == 'POST' and string.find(cons[id].req_client.uri, "^/v[%.%d]+/containers/create") then
		local prf = 'containers/create'
		
		local req_json = dkjson.decode(httprequestparser.getRequestBodyAsString(cons[id].req_client.buff))
		--print(util.dumpvar(req_json))
		
		if pl_types.is_empty(req_json.Labels) then
			req_json.Labels = docker_label_owner
		else
			for k,v in pairs(docker_label_owner) do
				req_json.Labels[k] = v
			end
		end
		
		change_request(id, dkjson.encode(req_json))
		
		if DEBUG then log.debug("(%d) %s; add_owner_label: %s", id, prf, dkjson.encode(add_label)) end
		return true
	end
	
	
	return true
end

local function filtered_owner(id)
	-- is tcp connect
	if cons[id].is_tcp then
		return true
	end
	
	-- disabled added all labels
	if optarg["no_add_all_labels"] then
		return true
	end
	--print(cons[id].req_client.method .. " " .. cons[id].req_client.uri_long)
	
	local function _get_filters()
		local docker_owner_label_for_filters = {};
		for k,v in pairs(docker_label_owner) do
			docker_owner_label_for_filters[k.."="..v] = true
		end
		
		local filters = {}
		if pl_types.is_empty(cons[id].req_client.params.filters) then
			filters = {label = docker_owner_label_for_filters}
		else
			filters = dkjson.decode(cons[id].req_client.params.filters)
			--print(util.dumpvar(filters))
			if pl_types.is_empty(filters.label) then
				filters.label = docker_owner_label_for_filters
			else
				filters.label = pl_tablex.merge(filters.label, docker_owner_label_for_filters, true)
			end
		end
		
		if DEBUG then log.debug("(%d) %s; added query params: filters->label: %s", id, prf, dkjson.encode(docker_owner_label_for_filters)) end
		return filters
	end
	
	
	if cons[id].req_client.method == 'GET' and string.find(cons[id].req_client.uri, "^/v[%.%d]+/containers/json") then
		local prf = 'containers/json'
		
		cons[id].req_client.params["filters"] = dkjson.encode(_get_filters())
		change_request(id, "")
		
		return true
	end
	
	
	return true
end

local function check_acl(id, acl)
	-- is tcp connect
	if cons[id].is_tcp then
		return true
	end
	
	-- disable acl
	if optarg["no_acl"] then
		return true
	end
	--print(util.dumpvar(cons[id].req_client))
	
	
	if cons[id].req_client.method == 'POST' and string.find(cons[id].req_client.uri, "^/v[%.%d]+/containers/create") then
		local prf = 'containers/create'
		
		if not acl.containers.create.allow then
			return nil, prf
		end
		
		local req_json = dkjson.decode(httprequestparser.getRequestBodyAsString(cons[id].req_client.buff))
		
		if not acl.containers.create.json.HostConfig.Privileged then
			if req_json.HostConfig ~= nil and req_json.HostConfig.Privileged then
				return nil, prf..": --privileged"
			end
		end
	end
	
	
	return true
end

local function make_request(id, chunk)
	-- is tcp connect
	if cons[id].is_tcp then
		cons[id].req_client.buff = chunk
		return true
	end
	
	-- is new http request?
	if cons[id].req_client.is_ready then
		cons[id].req_client = get_empty_req_client()
	end
	
	-- as a rule, all the headlines will fit into the first chunk (see: concli:recv(-1024))
	if string.len(cons[id].req_client.buff) == 0 then
		cons[id].req_client.headers      = httprequestparser.getAllHeaders(chunk)
		cons[id].req_client.method       = httprequestparser.getHttpMethod(chunk)
		cons[id].req_client.http_version = httprequestparser.getHttpVersion(chunk)
		cons[id].req_client.uri_long     = http_util.decodeURIComponent(httprequestparser.getURI(chunk))
		
		local tt = pl_stringx.split(cons[id].req_client.uri_long, '?', 2)
		cons[id].req_client.uri = tt[1]
		if not pl_types.is_empty(tt[2]) then
			for k, v in http_util.query_args(tt[2]) do
				cons[id].req_client.params[k] = v
			end
		end
		
		
		if cons[id].req_client.headers['upgrade'] ~= nil and string.lower(cons[id].req_client.headers['upgrade']) == 'tcp' then
			if DEBUG then log.debug("(%d) connnection upgrade tcp", id) end
			cons[id].is_tcp = true
		end
	end
	
	-- save request
	cons[id].req_client.buff = cons[id].req_client.buff .. chunk
	
	-- if the "content-length" header are missing or equal to 0, then we assume that the request is completed
	if cons[id].req_client.headers['content-length'] == nil or tonumber(cons[id].req_client.headers['content-length']) == 0 then
		cons[id].req_client.is_ready = true
		--print("("..id .. ")"..util.dumpvar(cons[id].req_client))
		return true
	end
	
	-- the request is completed
	if string.len(httprequestparser.getRequestBodyAsString(cons[id].req_client.buff)) == tonumber(cons[id].req_client.headers['content-length']) then
		cons[id].req_client.is_ready = true
		--print("("..id .. ")"..util.dumpvar(cons[id].req_client))
		return true
	end
	
	--print("("..id .. ")".. string.len(httprequestparser.getRequestBodyAsString(cons[id].req_client.buff)) .. " == " .. cons[id].req_client.headers['content-length'])
	return false
end

local function handle_tcp(concli, id, ip, port)
	local conback = socket.connect({path = optarg['docker_sock']})
	
	concli:setmode("b", "bn")
	conback:setmode("b", "bn")
	
	-- read concli -> write conback
	loop:wrap(function()
		if DEBUG then log.debug("(%d) concli_coroutine start", id) end
		
		while true do
			if conback:eof("r") then concli:shutdown('w'); break end
			
			local chunk, why = concli:recv(-1024)
			if not chunk then
				--print("(" .. id .. " concli why) " .. why)
				if why == EPIPE then -- connection closed client
					break
				else
					poll(concli, cons[id].condvar,  5)
				end
			else
				--print("(" .. id .. " conback:write) " .. chunk)
				if make_request(id, chunk) then
					local ok, err = check_acl(id, acl)
					if ok then
						add_owner_label(id)
						
						filtered_owner(id)
						
						-- TODO error handling
						conback:send(cons[id].req_client.buff, 1, string.len(cons[id].req_client.buff))
					else
						send_deny_to_client(concli, err)
					end
				end
			end
		end
		
		if cons[id] then cons[id].condvar:signal() end
		if DEBUG then log.debug("(%d) concli_coroutine stop", id) end
	end)
	
	
	-- read conback -> write concli
	loop:wrap(function()
		if DEBUG then log.debug("(%d) conback_coroutine start", id) end
		
		while true do
			if concli:eof("r") then conback:shutdown('w') end
			
			local chunk, why = conback:recv(-1024)
			if not chunk then
				--print("(" .. id .. " conback why) " .. why)
				if why == EPIPE then -- connection closed backend
					break
				else
					poll(conback, cons[id].condvar, 5)
				end
			else
				--print("(" .. id .. " concli:write) " .. chunk)
				-- TODO error handling
				concli:send(chunk, 1, #chunk)
			end
		end
		
		if cons[id] then cons[id].condvar:signal() end
		if DEBUG then log.debug("(%d) conback_coroutine stop", id) end
	end)
	
	
	-- waiting for events on the sockets
	if DEBUG then log.debug("(%d) condvar:wait (concli and conback)", id) end
	cons[id].condvar:wait()
	
	
	-- waiting for the backend to complete the data transfer to the client
	if (not conback:eof("r")) then
		if DEBUG then log.debug("(%d) condvar:wait (conback)", id) end
		cons[id].condvar:wait()
	end
	
	conback:close()
end

loop:wrap(function()
	local count = 0
	
	for concli in srv:clients() do
		count = count + 1
		
		local id = count
		cons[id] = {
			condvar    = condition.new(),
			is_tcp     = false,                 -- do not filter such a connection
			req_client = get_empty_req_client() -- client request
		}
		
		loop:wrap(function()
			local _, ip, port = concli:peername()
			ip   = ip   or "unix"
			port = port or 0
			
			log.info("(%d) %s:%d: connected", id, ip, port)
			
			local ok, why = pcall(handle_tcp, concli, id, ip, port)
			if ok then
				log.info("(%d) %s:%d: disconnected", id, ip, port)
			else
				log.warn("(%d) %s:%d: %s", id, ip, port, why)
			end
			
			concli:close()
			cons[id] = nil
		end)
	end
end)


local signal_listen = signal.listen(signal.SIGTERM, signal.SIGINT)
signal.block(signal.SIGTERM, signal.SIGINT)
loop:wrap(function()
	local signo
	while true do
		signo = signal_listen:wait(0.2)
		if signo == signal.SIGINT or signo == signal.SIGTERM then
			log.info('get signal INT or TERM, stop daemon')
			os.exit(0)
		end
	end
end)


while not loop:empty() do
	local ok, err = loop:step()
	if not ok then
		log.err("loop.step: %s", err)
		
		-- ERRO; 1721199665; loop.step: ./proxydockersockd:190: socket:accept: Permission denied
		if string.find(err, 'socket:accept', 1, true) then
			os.exit(1)
		end
	end
end
